#include <iostream>  
/*算法思想：

　　――在给定的装载问题有解的情况下

　　最优装载方案： 首先将第一艘轮船尽可能的装满；　　

　　　　　　　　　 然后将剩余的集装箱装上第二艘轮船。

　　将第一艘轮船尽可能的装满等价于选取全体集装箱的一个子集，使该子集中集装箱重量之和最接近c1。

算法设计：

　　先考虑装载一艘轮船的情况，依次讨论每个集装箱的装载情况，共分为两种，要么装(1)，要么不装(0)，因此很明显其解空间树可以用子集树来表示。

　　在算法Maxloading中，返回不超过c的最大子集和，但是并没有给出到达这个最大子集和的相应子集，稍后完善。

　　在算法Maxloading中，调用递归函数Backtrack(1)实现回溯搜索。Backtrack(i)搜索子集树中的第i层子树。

　　在算法Backtrack中，当i>n时，算法搜索到叶结点，其相应的载重量为cw，如果cw>bestw，则表示当前解优于当前的最优解，此时应该更新bestw。

　　算法Backtrack动态地生成问题的解空间树。在每个结点处算法花费O(1)时间。子集树中结点个数为O(2^n)，故Backtrack所需的时间为O(2^n)。另外Backtrack还需要额外的O(n)的递归栈空间。*/
using namespace std;

int c1, c2;         //分别载重量  
int n;              //集装箱数量  
int w[100];         //集装箱重量  
int cw;             //c1当前载重量  
int bestw;          //c1当前最优载重量  
int r;              //剩余集装箱重量  未考察过的集装箱的重量，并非没有装载的集装箱重量
int x[100];         //当前解  
int bestx[100];      //当前最优解  

void Backtrack(int i)
{
	if (i > n)  //到达叶结点
	{
		//当前解由于最优解，更新之  //回溯搜索 搜索第i层结点
		if (cw > bestw)
		{
			for (int j = 1; j <= n; j++)
				bestx[j] = x[j];
			bestw = cw;
		}
		return;
	}

	//引入剪枝函数，用于剪去不含最优解的子树：即当cw(当前载重量)+r(未考察对象的总重量)<bestw(当前的最优载重量)时当前子树不可能包含最优解，直接减掉。
	//搜索子树,放入或不放入  如果当前c1的载重量+当前节点的子树的最大重量都没有betsw（最优载重量）大，不放入当前的重量  
    //就不再向当前节点的右子树移动了，即剪枝。  
	r -= w[i];              //剩余容量集合去掉w[i]   计算剩余（未考察）的集装箱的重量，减去当前考察过的对象的重量
	if (cw + w[i] <= c1)     //可放入，且放入  搜索左子树
	{
		x[i] = 1;           //放入  
		cw += w[i];           //当前载重量增加正考虑对象的重量
		Backtrack(i + 1);

		cw -= w[i];      //递归返回上一层时，记得减去刚考虑对象的集装箱重量
	}
	if (cw + r > bestw)      //剩余容量集合依然是去掉w[i],因为w[i]不放入 搜索右子树――――――剪枝函数 
	{
		x[i] = 0;
		Backtrack(i + 1);
	}

	r += w[i];              //回溯  //递归返回上一层时，记得修改r的值，如果取不到最优解，再取消当前考虑的集装箱，标记为未选，因此剩余容量要再加上当前集装箱重量
}

int main()
{
	while ((cin >> c1 >> c2 >> n) && n)
	{
		cw = 0;             //每组样例初始化  
		r = 0;
		bestw = 0;

		for (int i = 1; i <= n; i++)
		{
			cin >> w[i];
			r += w[i];
		}
		Backtrack(1);
		if (r - bestw <= c2)
			cout << "Yes" << endl;
		else
			cout << "No" << endl;
	}

	return 0;
}